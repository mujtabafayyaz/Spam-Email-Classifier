# -*- coding: utf-8 -*-
"""spamclassifier.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PlRHca-Z2nOXPscKjiPzZl0tVfXV2HU8

# Spam Classifier
## Assignment Preamble
Please ensure you carefully read all of the details and instructions on the assignment page, this section, and the rest of the notebook. If anything is unclear at any time please post on the forum or ask a tutor well in advance of the assignment deadline.

In addition to all of the instructions in the body of the assignment below, you must also follow the following technical instructions for all assignments in this unit. *Failure to do so may result in a grade of zero.*
* [At the bottom of the page](#Submission-Test) is some code which checks you meet the submission requirements. You **must** ensure that this runs correctly before submission.
* Do not modify or delete any of the cells that are marked as test cells, even if they appear to be empty.
* Do not duplicate any cells in the notebook – this can break the marking script. Instead, insert a new cell (e.g. from the menu) and copy across any contents as necessary.
* Do not use global variables or rely on global state at all. It may lose you marks in the marking script.

Remember to save and backup your work regularly, and double-check you are submitting the correct version.

This notebook is the primary reference for your submission. You may write code in separate `.py` files but it must be clearly imported into the notebook so that it runs without needing to reference those files, and you must explain clearly what functionality is contained in those files (through comments, markdown cells, etc).

As always, **the work you submit for this assignment must be entirely your own.** Do not copy or work with other students. Do not copy answers that you find online. These assignments are designed to help improve your understanding first and foremost – the process of doing the assignment is part of *learning*. They are also used to assess your ability, and so you must uphold academic integrity. Submitting plagiarised work risks your entire place on your degree.

**The pass mark for this assignment is 40%.** We expect that students, on average, will be able to produce a submission which gets a mark between 50-70% within the normal workload allocation for the unit, but this will vary depending on individual backgrounds. Please ask for help if you are struggling.

## Getting Started
Spam refers to unwanted email, often in the form of advertisements. In the literature, an email that is **not** spam is called *ham*. Most email providers offer automatic spam filtering, where spam emails will be moved to a separate inbox based on their contents. Of course this requires being able to scan an email and determine whether it is spam or ham, a classification problem. This is the subject of this assignment.

This assignment has one part, worth 100% of the grade for this coursework.

You will write a supervised learning based classifier to determine whether a given email is spam or ham. You must write and submit the code in this notebook. The training data is provided for you. You may use any classification method. Marks will be awarded primarily based on the accuracy of your classifier on unseen test data, but there are also marks for estimating how accurate you think your classifier will be.

### Choice of Algorithm
While the classification method is a completely free choice, the assignment folder includes [a separate notebook file](data/naivebayes.ipynb) which can help you implement a Naïve Bayes solution. If you do use this notebook, you are still responsible for porting your code into *this* notebook for submission. A good implementation should give a high  enough accuracy to get a good grade on this section (50-70%).

You could also consider a k-nearest neighbour algorithm, but this may be less accurate. Logistic regression is another option that you may wish to consider.

If you are looking to go beyond the scope of the unit, you might be interested in building something more advanced, like an artificial neural network. This is possible just using `numpy`, but will require significant self-directed learning. *Extensions like this are left unguided and are not factored into the unit workload estimates.*

**Note:** you may use helper functions in libraries like `numpy` or `scipy`, but you **must not** import code which builds entire models for you. This includes but is not limited to use of libraries like `scikit-learn`, `tensorflow`, or `pytorch` – there will be plenty of opportunities for these libraries in later units. The point of this assignment is to understand code the actual algorithm yourself. ***If you are in any doubt about any particular library or function please ask a tutor.*** Submissions which ignore this will receive penalties or even zero marks.

## Training Data
The training data is described below and has 1000 rows. There is also a 500 row set of test data. These are functionally identical to the training data, they are just in a separate csv file to encourage you to split out your training and test data. You should consider how to best make use of all available data without overfitting, and to help produce an unbiased estimate for your classifier's accuracy.

The cell below loads the training data into a variable called `training_spam`.
"""

import numpy as np

training_spam = np.loadtxt(open("data/training_spam.csv"), delimiter=",").astype(np.int)
print("Shape of the spam training data set:", training_spam.shape)
print(training_spam)

"""Your training set consists of 1000 rows and 55 columns. Each row corresponds to one email message. The first column is the _response_ variable and describes whether a message is spam `1` or ham `0`. The remaining 54 columns are _features_ that you will use to build a classifier. These features correspond to 54 different keywords (such as "money", "free", and "receive") and special characters (such as ":", "!", and "$"). A feature has the value `1` if the keyword appears in the message and `0` otherwise.

As mentioned there is also a 500 row set of *test data*. It contains the same 55 columns.
"""

testing_spam = np.loadtxt(open("data/testing_spam.csv"), delimiter=",").astype(np.int)
print("Shape of the spam testing data set:", testing_spam.shape)
print(testing_spam)

"""## Part One
Write all of the code for your classifier below this cell. There is some very rough skeleton code in the cell directly below. You may insert more cells below this if you wish, but you must not duplicate any cells as this can break the grading script.

### Submission Requirements
Your code must provide a variable with the name `classifier`. This object must have a method called `predict` which takes input data and returns class predictions. The input will be a single $n \times 54$ numpy array, your classifier should return a numpy array of length $n$ with classifications. There is a demo in the cell below, and a test you can run before submitting to check your code is working correctly.

Your code must run on our test machine in under 30 seconds. If you wish to train a more complicated model (e.g. neural network) which will take longer, you are welcome to save the model's weights as a file and then load these in the cell below so we can test it. You must include the code which computes the original weights, but this must not run when we run the notebook – comment out the code which actually executes the routine and make sure it is clear what we need to change to get it to run. Remember that we will be testing your final classifier on additional hidden data.
"""

import math
import numpy as np
# This skeleton code simply classifies every input as ham
#
# Here you can see there is a parameter k that is unused, the
# point is to show you how you could set up your own. You might
# also pass in extra data via a train method (also does nothing
# here). Modify this code as much as you like so long as the 
# accuracy test in the cell below runs.

class SpamClassifier:
    def __init__(self, training_spam, testing_spam):
        self.training_spam = training_spam
        self.testing_spam = testing_spam
        
    def train(self):
        self.log_class_priors = self.estimate_log_class_priors()
        self.log_class_conditional_likelihoods = self.estimate_log_class_conditional_likelihoods(alpha=1.0)

    def estimate_log_class_priors(self):
        shape = self.training_spam.shape
        num_rows_training = shape[0]
        num_rows_testing = self.testing_spam.shape[0]

        spam_total = 0
        for i in range(0, num_rows_training):
            compare = self.training_spam[i][0]
            if compare == 1:
                spam_total += 1

        for j in range(0, num_rows_testing):
            compare = self.testing_spam[j][0]
            if compare == 1:
                spam_total += 1

        p_spam = spam_total / (num_rows_training + num_rows_testing)
        p_ham = 1 - p_spam
        log_class_priors = np.array([math.log(p_ham), math.log(p_spam)])


        return log_class_priors

    def estimate_log_class_conditional_likelihoods(self, alpha=1.0):
        num_rows_training = self.training_spam.shape[0]
        num_columns_training = self.training_spam.shape[1]

        num_rows_testing = self.testing_spam.shape[0]
        num_columns_testing = self.testing_spam.shape[1]

        theta = np.empty(shape = (2, num_columns_training - 1))
        theta.fill(0)

        ham_feature_total = 0
        spam_feature_total = 0 
        
        for i in range(0, num_rows_training):
            for j in range(0, num_columns_training):
                if(self.training_spam[i][0] == 0):
                    if(self.training_spam[i][j] == 1 and j != 0):
                        theta[0][j-1] += 1
                        ham_feature_total += 1
                elif(self.training_spam[i][0] == 1):
                    if(self.training_spam[i][j] == 1 and j != 0):
                        theta[1][j-1] += 1
                        spam_feature_total += 1

        for i in range(0, num_rows_testing):
            for j in range(0, num_columns_testing):
                if(self.testing_spam[i][0] == 0):
                    if(self.testing_spam[i][j] == 1 and j != 0):
                        theta[0][j-1] += 1
                        ham_feature_total += 1
                elif(self.testing_spam[i][0] == 1):
                    if(self.testing_spam[i][j] == 1 and j != 0):
                        theta[1][j-1] += 1
                        spam_feature_total += 1


        for i in range(0, 2):
            for j in range(0, num_columns_training - 1):
                if(theta[i][j] == 0):
                    theta += alpha
                    ham_feature_total += 54 * alpha
                    spam_feature_total += 54 * alpha
                    break
            else:
                continue
            break
                
        for i in range(0, 2):
            for j in range(0, num_columns_training - 1):
                if(i == 0):
                    theta[i][j] = theta[i][j] / ham_feature_total
                    theta[i][j] = math.log(theta[i][j])
                elif(i == 1):
                    theta[i][j] = theta[i][j] / spam_feature_total
                    theta[i][j] = math.log(theta[i][j])

        return theta
        
    def predict(self, new_data):
        data_num_rows = new_data.shape[0]
        likelihoods_num_cols = self.log_class_conditional_likelihoods.shape[1]

        class_predictions = np.empty(shape = (data_num_rows,))
        class_predictions.fill(1)

        for i in range(0, data_num_rows):
            ham_preditiction = self.log_class_priors[0]
            spam_prediction = self.log_class_priors[1]
            for j in range(0, likelihoods_num_cols):
                if(new_data[i,j] == 1):
                    ham_preditiction += self.log_class_conditional_likelihoods[0][j]
                    spam_prediction += self.log_class_conditional_likelihoods[1][j]
            if(ham_preditiction > spam_prediction):
                class_predictions[i] = 0
            else:
                class_predictions[i] = 1

        return class_predictions
    

def create_classifier():
    training_spam = np.loadtxt(open("data/training_spam.csv"), delimiter=",")
    testing_spam = np.loadtxt(open("data/testing_spam.csv"), delimiter = ",")
    classifier = SpamClassifier(training_spam, testing_spam)
    classifier.train()
    return classifier

classifier = create_classifier()

